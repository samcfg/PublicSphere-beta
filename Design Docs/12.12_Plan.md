The "NEOPLAN" is fairly outdated, I'm working off based on features that I find necessary via testing. 
# Making the Graph Dynamic
## 1. Editing Nodes
I found the need to do that, but immediately find it problematic. The owner of the node (isown=true) controls the editing capability. 
### Editing Nodes cutoff
After some time and usage, nodes become important collective resources, so An edit suggestion functionality that is ultimately used more often (separate from a report function). The threshhold: 
  def can_edit_own(node):
      time_hours = hours_since_creation(node)
      engagement = (
          node.ratings_count +
          node.comments_count +
          (node.incoming_connections_count * 3)  # connections weighted heavily
      )
      # Grace period: always editable for first hour
      if time_hours < 1:
          return True
      # Engagement threshold: if used in deliberation, lock it
      if engagement >= 5:  # tune this
          return False
      # Time decay: editable window shrinks with time
      max_hours = 24
      if time_hours >= max_hours:
          return False
      return True
    

## 2. Suggesting node and connection modifications
Shown in a sidebar in the node page. Community support should be given by ratings. From these suggested modifications, should come forks, and edits. 
### Forking
Automatic with suggestion, (creating a standalone node that is really only reachable through search), or suggest -> fork proccess?
**Prompt:** Modify? Modifications are for improving the overall quality of a node's writing. To argue about its content, rate, comment, or # 2.Reporting if problematic (tos)
**Prompt: modification -> Fork**: Make a different node based on this one
- This may solve the potential problem of users adding dualing nodes instead of arguing with contradictory nodes.  
- Also track the context in which a node was created if using createnodemodal in version table? 
### Splitting/elaborating connections into component arguments
Sometimes, an argument is written initially in an oversimilified way, so that reworking the overall number of connections and nodes is necessary. This is argument refactoring - restructuring for clarity without changing substance. 
  Mechanism:
  1. User selects connection as "contains multiple inference steps"
  2. recommend existing alternate path? (displays paths) or propose new one? 
     1. Proposes split: Source → [New Intermediate Claim] → Original Claim
        1. Creates that alternate path for new users to see Goes in the equivalent of suggestedit
     2. Views displays all paths from one claim to another to see current alternatives, reduces redundancy. Selects that for replacement, else: 
  3. Community votes on whether split improves clarity
  4. If approved, replaces conflated connection with elaborated chain


## 3.Reporting 
Button along with the others, flag, nothing fancy. simple modal, wire it to django modding. 

# Making the Graph pretty
## 4. Zooming and panning
All potentially based in an @viewport.jsx file. Premise:
### A. acvitve on node click
if that node is relatively out of view, pan to bring that node closer to the center of the screen, therefore revealing its dependencies. 
### B. Now, when clicking the "add node" button 
on onclicknode DOM, two new boxes appear that may be out of frame initially. I want the frame to move itself in a smooth pan so that those become visible. 

## 5. CreateNodeModal Revamp
Change font, make animation, make lines. 

# Making the whole site polished better
## 6. Consolidate fonts and colors

## 7. Homepage revamp

## 8. Merge NodeBox and StandaloneNodeCreationModal.jsx
  Shared Elements

  Both components use identical:
  - Form structure: Node type buttons (Claim/Evidence), content textarea, source title/URL fields
  - CSS classes: .node-creation-field, .node-creation-label, .node-creation-type-btn, .node-creation-input,
  .node-creation-textarea
  - Validation logic: Title required for sources, content required for all
  - Error handling: Duplicate detection for claims (exact/similar), sources (URL/title), with formatted error
  displays
  - API integration: Same createClaim() / createSource() calls
  ---
  Key Differences
  1. Component Pattern

  - NodeBox: Controlled component. Parent manages state, passes down via props
    - Used in compound connections (multiple NodeBoxes stacked)
    - Supports index prop for "Node 2", "Node 3" labels
    - Optional showControls prop (only first box shows buttons)
  - StandaloneNodeCreationModal: Owns all state
    - Self-contained modal with backdrop (<div className="modal-backdrop">)
    - Single-purpose: create one standalone node

  ~200 lines of duplicate logic exist between the two:
  1. Form field rendering (title/URL/content inputs)
  2. Validation checks (title required for sources)
  3. Error handling (duplicate detection, title_required)
  4. API call patterns

## 9. SourceNodeCreation [[metapackets]]
