from django.db import models
from django.conf import settings

class ClaimVersion(models.Model):
    """Claim version history table - tracks all changes to Claim nodes"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    node_id = models.CharField(max_length=255, db_index=True)

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Claim properties (mirrors PS_Graph_DB BasicSchema Claim node)
    content = models.TextField(null=True, blank=True)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'claim_versions'
        indexes = [
            models.Index(fields=['node_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['node_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['node_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"Claim {self.node_id} ({self.operation} at {self.timestamp})"


class SourceVersion(models.Model):
    """Source version history table - tracks all changes to Source nodes"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    node_id = models.CharField(max_length=255, db_index=True)

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Source properties (mirrors PS_Graph_DB BasicSchema Source node)
    url = models.URLField(max_length=500, null=True, blank=True)
    title = models.CharField(max_length=500, null=True, blank=True)
    author = models.CharField(max_length=200, null=True, blank=True)
    publication_date = models.CharField(max_length=100, null=True, blank=True)
    source_type = models.CharField(max_length=50, null=True, blank=True)  # 'web', 'book', 'paper', 'observation'
    content = models.TextField(null=True, blank=True)  # quotes/excerpts

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'source_versions'
        indexes = [
            models.Index(fields=['node_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['node_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['node_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"Source {self.node_id} ({self.operation} at {self.timestamp})"


class EdgeVersion(models.Model):
    """Edge version history table - tracks all changes to graph edges"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    edge_id = models.CharField(max_length=255, db_index=True)
    edge_type = models.CharField(max_length=100)  # Edge type (e.g., 'Connection')

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Graph topology
    source_node_id = models.CharField(max_length=255)
    target_node_id = models.CharField(max_length=255)

    # Graph properties (mirrors PS_Graph_DB BasicSchema edges)
    notes = models.TextField(null=True, blank=True)
    logic_type = models.CharField(max_length=10, null=True, blank=True)  # 'AND', 'OR'
    composite_id = models.CharField(max_length=36, null=True, blank=True, db_index=True)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'edge_versions'
        indexes = [
            models.Index(fields=['edge_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['source_node_id', 'target_node_id']),
            models.Index(fields=['edge_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['edge_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"{self.edge_type} {self.edge_id} ({self.operation} at {self.timestamp})"
