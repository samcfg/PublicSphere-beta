from django.db import models
from django.conf import settings

class ClaimVersion(models.Model):
    """Claim version history table - tracks all changes to Claim nodes"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    node_id = models.CharField(max_length=255, db_index=True)

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Claim properties (mirrors PS_Graph_DB BasicSchema Claim node)
    content = models.TextField(null=True, blank=True)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'claim_versions'
        indexes = [
            models.Index(fields=['node_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['node_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['node_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"Claim {self.node_id} ({self.operation} at {self.timestamp})"


class SourceVersion(models.Model):
    """Source version history table - tracks all changes to Source nodes"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    node_id = models.CharField(max_length=255, db_index=True)

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Source properties (mirrors PS_Graph_DB BasicSchema Source node)
    url = models.URLField(max_length=500, null=True, blank=True)
    title = models.CharField(max_length=500, null=True, blank=True)
    author = models.CharField(max_length=200, null=True, blank=True)
    publication_date = models.CharField(max_length=100, null=True, blank=True)
    source_type = models.CharField(max_length=50, null=True, blank=True)  # 'web', 'book', 'paper', 'observation'
    content = models.TextField(null=True, blank=True)  # quotes/excerpts

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'source_versions'
        indexes = [
            models.Index(fields=['node_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['node_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['node_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"Source {self.node_id} ({self.operation} at {self.timestamp})"


class EdgeVersion(models.Model):
    """Edge version history table - tracks all changes to graph edges"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    edge_id = models.CharField(max_length=255, db_index=True)
    edge_type = models.CharField(max_length=100)  # Edge type (e.g., 'Connection')

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Graph topology
    source_node_id = models.CharField(max_length=255)
    target_node_id = models.CharField(max_length=255)

    # Graph properties (mirrors PS_Graph_DB BasicSchema edges)
    notes = models.TextField(null=True, blank=True)
    logic_type = models.CharField(max_length=10, null=True, blank=True)  # 'AND', 'OR'
    composite_id = models.CharField(max_length=36, null=True, blank=True, db_index=True)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'edge_versions'
        indexes = [
            models.Index(fields=['edge_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['source_node_id', 'target_node_id']),
            models.Index(fields=['edge_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['edge_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"{self.edge_type} {self.edge_id} ({self.operation} at {self.timestamp})"


class RatingVersion(models.Model):
    """Rating version history table - tracks all changes to ratings"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Rating reference
    rating_id = models.IntegerField(db_index=True, help_text="ID of the Rating in social app")

    # Version tracking (sequential version number per rating)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Rating properties (snapshot of Rating model state)
    user_id = models.IntegerField(help_text="User who created/modified the rating")
    entity_uuid = models.CharField(max_length=36)
    entity_type = models.CharField(max_length=20)
    dimension = models.CharField(max_length=20, null=True, blank=True)
    score = models.FloatField()

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'rating_versions'
        indexes = [
            models.Index(fields=['rating_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['rating_id', 'version_number']),
            models.Index(fields=['entity_uuid']),  # Lookup ratings by entity
        ]
        unique_together = [['rating_id', 'version_number']]

    def __str__(self):
        return f"Rating {self.rating_id} v{self.version_number} ({self.operation} at {self.timestamp})"


class CommentVersion(models.Model):
    """Comment version history table - tracks all changes to comments"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Comment reference
    comment_id = models.IntegerField(db_index=True, help_text="ID of the Comment in social app")

    # Version tracking (sequential version number per comment)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Comment properties (snapshot of Comment model state)
    user_id = models.IntegerField(null=True, help_text="User who created/modified the comment")
    entity_uuid = models.CharField(max_length=36)
    entity_type = models.CharField(max_length=20)
    content = models.TextField()
    parent_comment_id = models.IntegerField(null=True, blank=True)
    is_deleted = models.BooleanField(default=False)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),  # Soft delete or hard delete
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'comment_versions'
        indexes = [
            models.Index(fields=['comment_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['comment_id', 'version_number']),
            models.Index(fields=['entity_uuid']),  # Lookup comments by entity
        ]
        unique_together = [['comment_id', 'version_number']]

    def __str__(self):
        return f"Comment {self.comment_id} v{self.version_number} ({self.operation} at {self.timestamp})"
