from django.db import models
from django.conf import settings
from django.contrib.postgres.search import SearchVectorField
from django.contrib.postgres.indexes import GinIndex

class ClaimVersion(models.Model):
    """Claim version history table - tracks all changes to Claim nodes"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    node_id = models.CharField(max_length=255, db_index=True)

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Claim properties (mirrors PS_Graph_DB BasicSchema Claim node)
    content = models.TextField(null=True, blank=True)

    # Search and deduplication fields
    content_search = SearchVectorField(null=True, blank=True)
    # ↑ Auto-populated by DB trigger on INSERT/UPDATE. Full-text search index.
    content_normalized = models.TextField(null=True, blank=True, db_index=True)
    # ↑ Auto-populated via save() override. Canonical form for exact duplicate detection.

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'claim_versions'
        indexes = [
            models.Index(fields=['node_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['node_id', 'version_number']),  # Lookup by entity + version
            GinIndex(fields=['content_search'], name='claim_content_search_idx'),  # Full-text search (Phase 3)
            GinIndex(fields=['content'], opclasses=['gin_trgm_ops'], name='claim_content_trgm_idx'),  # Trigram similarity (Phase 2)
        ]
        unique_together = [['node_id', 'version_number']]  # Ensure version uniqueness per entity

    def save(self, *args, **kwargs):
        """Override save to auto-populate normalized fields"""
        from graph.utils import normalize_content

        # Auto-populate content_normalized for exact duplicate detection
        if self.content:
            self.content_normalized = normalize_content(self.content)
        else:
            self.content_normalized = None

        super().save(*args, **kwargs)

    def __str__(self):
        return f"Claim {self.node_id} ({self.operation} at {self.timestamp})"


class SourceVersion(models.Model):
    """Source version history table - tracks all changes to Source nodes"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    node_id = models.CharField(max_length=255, db_index=True)

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # ===== CORE CITATION FIELDS =====

    # Required fields
    title = models.TextField(null=False, blank=False)  # REQUIRED - primary searchable identifier
    source_type = models.CharField(max_length=50, null=False, blank=False)
    # Values: 'journal_article', 'preprint', 'book', 'website', 'newspaper',
    #         'magazine', 'thesis', 'conference_paper', 'technical_report',
    #         'government_document', 'dataset', 'media', 'legal', 'testimony'

    # Universal optional fields (all source types)
    thumbnail_link = models.URLField(max_length=2048, null=True, blank=True)
    authors = models.JSONField(null=True, blank=True)
    # Structure: [{"name": "...", "role": "author"}]
    url = models.URLField(max_length=2048, null=True, blank=True)
    accessed_date = models.DateField(null=True, blank=True)
    excerpt = models.TextField(null=True, blank=True)
    content = models.TextField(null=True, blank=True)

    # Publication metadata
    publication_date = models.CharField(max_length=100, null=True, blank=True)
    # ISO 8601 preferred, but accepts partial dates: "2024", "2024-03", "2024-03-15"
    container_title = models.TextField(null=True, blank=True)
    # Journal name, book title (for chapters), website name, conference name
    publisher = models.CharField(max_length=255, null=True, blank=True)
    publisher_location = models.CharField(max_length=255, null=True, blank=True)

    # Volume/Issue/Pages
    volume = models.CharField(max_length=50, null=True, blank=True)
    issue = models.CharField(max_length=50, null=True, blank=True)
    pages = models.CharField(max_length=50, null=True, blank=True)  # "123-145" or "E456"

    # Book-specific
    edition = models.CharField(max_length=50, null=True, blank=True)

    # Identifiers
    doi = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    # Digital Object Identifier - unique, persistent
    isbn = models.CharField(max_length=20, null=True, blank=True)
    issn = models.CharField(max_length=20, null=True, blank=True)
    pmid = models.CharField(max_length=20, null=True, blank=True)
    pmcid = models.CharField(max_length=20, null=True, blank=True)
    arxiv_id = models.CharField(max_length=50, null=True, blank=True)
    handle = models.CharField(max_length=255, null=True, blank=True)
    persistent_id = models.CharField(max_length=255, null=True, blank=True)
    persistent_id_type = models.CharField(max_length=50, null=True, blank=True)

    # Editors
    editors = models.JSONField(null=True, blank=True)
    # Structure: [{"name": "...", "role": "editor"}]

    # Legal-specific fields
    jurisdiction = models.CharField(max_length=255, null=True, blank=True)
    legal_category = models.CharField(max_length=50, null=True, blank=True)
    # Values: 'case', 'statute', 'regulation', 'treaty'
    court = models.CharField(max_length=255, null=True, blank=True)
    decision_date = models.CharField(max_length=100, null=True, blank=True)
    case_name = models.TextField(null=True, blank=True)
    code = models.CharField(max_length=255, null=True, blank=True)
    section = models.CharField(max_length=255, null=True, blank=True)

    # Flexible metadata overflow for type-specific edge cases
    metadata = models.JSONField(null=True, blank=True)

    # ===== SEARCH AND DEDUPLICATION FIELDS =====
    url_normalized = models.CharField(max_length=2048, null=True, blank=True, db_index=True)
    # ↑ Auto-populated from url via save() override. Canonical form for duplicate detection.
    doi_normalized = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    # ↑ Auto-populated from doi via save() override. Canonical form (lowercase, strip prefix).
    title_search = SearchVectorField(null=True, blank=True)
    # ↑ Auto-populated by DB trigger on INSERT/UPDATE. Full-text search on title.
    title_normalized = models.TextField(null=True, blank=True, db_index=True)
    # ↑ Auto-populated via save() override. Canonical form for exact duplicate detection.

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'source_versions'
        indexes = [
            models.Index(fields=['node_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['node_id', 'version_number']),  # Lookup by entity + version
            models.Index(fields=['source_type']),  # Filter by source type
            models.Index(fields=['url_normalized']),  # URL deduplication (Phase 1)
            models.Index(fields=['doi_normalized']),  # DOI deduplication (highest priority)
            models.Index(fields=['publication_date']),  # Chronological queries
            GinIndex(fields=['title_search'], name='source_title_search_idx'),  # Full-text search on title (Phase 3)
            GinIndex(fields=['title'], opclasses=['gin_trgm_ops'], name='source_title_trgm_idx'),  # Trigram similarity on title (Phase 2)
        ]
        unique_together = [['node_id', 'version_number']]  # Ensure version uniqueness per entity

    def save(self, *args, **kwargs):
        """Override save to auto-populate normalized fields"""
        from graph.utils import normalize_url, normalize_content, normalize_doi

        # Auto-populate url_normalized if url is provided
        if self.url:
            self.url_normalized = normalize_url(self.url)
        else:
            self.url_normalized = None

        # Auto-populate doi_normalized if doi is provided
        if self.doi:
            self.doi_normalized = normalize_doi(self.doi)
        else:
            self.doi_normalized = None

        # Auto-populate title_normalized for exact duplicate detection
        if self.title:
            self.title_normalized = normalize_content(self.title)
        else:
            self.title_normalized = None

        super().save(*args, **kwargs)

    def __str__(self):
        return f"Source {self.node_id} ({self.operation} at {self.timestamp})"


class EdgeVersion(models.Model):
    """Edge version history table - tracks all changes to graph edges"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Graph entity reference
    edge_id = models.CharField(max_length=255, db_index=True)
    edge_type = models.CharField(max_length=100)  # Edge type (e.g., 'Connection')

    # Version tracking (sequential version number per entity)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Graph topology
    source_node_id = models.CharField(max_length=255)
    target_node_id = models.CharField(max_length=255)

    # Graph properties (mirrors PS_Graph_DB BasicSchema edges)
    notes = models.TextField(null=True, blank=True)
    logic_type = models.CharField(max_length=10, null=True, blank=True)  # 'AND', 'OR'
    composite_id = models.CharField(max_length=36, null=True, blank=True, db_index=True)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    changed_by = models.CharField(max_length=255, null=True, blank=True)
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'edge_versions'
        indexes = [
            models.Index(fields=['edge_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['source_node_id', 'target_node_id']),
            models.Index(fields=['edge_id', 'version_number']),  # Lookup by entity + version
        ]
        unique_together = [['edge_id', 'version_number']]  # Ensure version uniqueness per entity

    def __str__(self):
        return f"{self.edge_type} {self.edge_id} ({self.operation} at {self.timestamp})"


class RatingVersion(models.Model):
    """Rating version history table - tracks all changes to ratings"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Rating reference
    rating_id = models.IntegerField(db_index=True, help_text="ID of the Rating in social app")

    # Version tracking (sequential version number per rating)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Rating properties (snapshot of Rating model state)
    user_id = models.IntegerField(help_text="User who created/modified the rating")
    entity_uuid = models.CharField(max_length=36)
    entity_type = models.CharField(max_length=20)
    dimension = models.CharField(max_length=20, null=True, blank=True)
    score = models.FloatField()

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'rating_versions'
        indexes = [
            models.Index(fields=['rating_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['rating_id', 'version_number']),
            models.Index(fields=['entity_uuid']),  # Lookup ratings by entity
        ]
        unique_together = [['rating_id', 'version_number']]

    def __str__(self):
        return f"Rating {self.rating_id} v{self.version_number} ({self.operation} at {self.timestamp})"


class CommentVersion(models.Model):
    """Comment version history table - tracks all changes to comments"""

    # Primary key (auto-generated by Django as BigAutoField)

    # Comment reference
    comment_id = models.IntegerField(db_index=True, help_text="ID of the Comment in social app")

    # Version tracking (sequential version number per comment)
    version_number = models.IntegerField(
        default=1,
        help_text="Sequential version number (v1, v2, v3...)"
    )

    # Comment properties (snapshot of Comment model state)
    user_id = models.IntegerField(null=True, help_text="User who created/modified the comment")
    entity_uuid = models.CharField(max_length=36)
    entity_type = models.CharField(max_length=20)
    content = models.TextField()
    parent_comment_id = models.IntegerField(null=True, blank=True)
    is_deleted = models.BooleanField(default=False)

    # Temporal metadata
    OPERATION_CHOICES = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),  # Soft delete or hard delete
    ]
    operation = models.CharField(max_length=20, choices=OPERATION_CHOICES)
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)
    valid_from = models.DateTimeField(auto_now_add=True)
    valid_to = models.DateTimeField(null=True, blank=True)

    # Audit trail
    change_notes = models.TextField(null=True, blank=True)

    class Meta:
        db_table = 'comment_versions'
        indexes = [
            models.Index(fields=['comment_id']),
            models.Index(fields=['timestamp']),
            models.Index(fields=['valid_from', 'valid_to']),
            models.Index(fields=['comment_id', 'version_number']),
            models.Index(fields=['entity_uuid']),  # Lookup comments by entity
        ]
        unique_together = [['comment_id', 'version_number']]

    def __str__(self):
        return f"Comment {self.comment_id} v{self.version_number} ({self.operation} at {self.timestamp})"
